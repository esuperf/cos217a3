#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <string.h>
#include "symtable.h"

struct Node {
   char *key;
   void *value;
   struct Node *next;
};

struct SymTable {
   struct Node *first;
};
   

SymTable_T SymTable_new(void) {
   SymTable_T newp = (SymTable_T) malloc(sizeof(SymTable_T));
   if (newp == NULL){
      return NULL;
   }
   newp->first = NULL;
   /*newp-> value = NULL;
   newp->next = NULL;
   */
   return newp;
}

void SymTable_free(SymTable_T oSymTable){
   struct Node *clear = oSymTable->first;
   while (clear != NULL){
      struct Node *next = clear->next;
      free(clear->key);
      free(clear);
      clear = next;
   }
   free(oSymTable);
}

size_t SymTable_getLength(SymTable_T oSymTable){
   size_t count = 0;
   struct Node *temp = oSymTable->first;
   while (temp != NULL){
      count++;
      temp = temp->next;
   }
   return count;
}

int SymTable_put(SymTable_T oSymTable,
                 const char *pcKey, const void *pvValue){
   struct Node *current;
   struct Node *p;

   assert (oSymTable != NULL && pcKey != NULL);
   
   for(current = oSymTable->first; current != NULL;
       current = current->next){
      if (strcmp(current->key, pcKey) == 0){
         return 0;
      }
   }
   
   p = malloc(sizeof(struct Node));
   if (p == NULL){
      return 0;
   }
   
   p->key = malloc(strlen(pcKey) + 1);
   if (p->key == NULL){
      free(p);
      return 0;
   }

   strcpy(p->key, pcKey);
   p->value = (void*) pvValue;
   p->next = oSymTable->first;
   oSymTable->first = p;

   return 1;
}

void *SymTable_replace(SymTable_T oSymTable,
                       const char *pcKey, const void *pvValue){
   struct Node *p;
   void *temp;
   assert(oSymTable != NULL && pcKey != NULL);
   
   for(p = oSymTable->first; p!= NULL; p = p->next){
      if(strcmp(p->key, pcKey) == 0){
         temp = p->value;
         p->value = (void*) pvValue;
         return temp;
      }
   }
   return NULL;
}

int SymTable_contains(SymTable_T oSymTable, const char *pcKey){
   struct Node *p;
   assert(oSymTable != NULL && pcKey != NULL);
   
   for(p = oSymTable->first; p!= NULL; p = p->next){
      if(strcmp(p->key, pcKey) == 0){
         return 1;
      }
   }
   return 0;
}


void *SymTable_get(SymTable_T oSymTable, const char *pcKey){
   struct Node *p;
   assert(oSymTable != NULL && pcKey != NULL);
   
   for(p = oSymTable->first; p!= NULL; p = p->next){
      if(strcmp(p->key, pcKey) == 0){
         return p->value;
      }
   }
   return NULL;
}

void *SymTable_remove(SymTable_T oSymTable, const char *pcKey){
   struct Node *p;
   struct Node *prev = NULL;
   void *store;
   assert(oSymTable != NULL && pcKey != NULL);
   
   for (p = oSymTable->first; p != NULL; prev = p, p = p->next){
      if (strcmp(p->key, pcKey) == 0){
         store = p->value;

         if (prev == NULL){
            oSymTable->first = p->next;
         }
         else {
            prev->next = p->next;
         }
         
         free(p->key);
         free(p);
         return store;
      }
   }
   return NULL;
}

void SymTable_map(SymTable_T oSymTable, void(*pfApply)
                  (const char *pcKey, void *pvValue, void *pvExtra),
                  const void *pvExtra){
   struct Node *p;
   assert(oSymTable != NULL && pfApply != NULL);
   /*if (oSymTable == NULL || pfApply == NULL){
     return NULL}*/

   for (p = oSymTable->first; p != NULL; p = p->next){
      if (p->first->next != NULL){
         (*pfApply)(p->key, p->value, (void*)pvExtra);
      }
   }
}
